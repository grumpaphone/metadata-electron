import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import { Wavedata, FileInfo, MirrorConfiguration } from '../types';
import * as chokidar from 'chokidar';
import { CHANNELS } from '../ipc-api';
import { metadataService } from './services/MetadataService';
import { filenameParser } from './services/FilenameParser';
import { mirrorService } from './services/MirrorService';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
	app.quit();
}

let mainWindow: BrowserWindow;
let fileWatcher: chokidar.FSWatcher | null = null;

const createWindow = () => {
	console.log('[MAIN] Creating window...');
	console.log('[MAIN] Preload path:', MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);
	console.log('[MAIN] Renderer path:', MAIN_WINDOW_WEBPACK_ENTRY);
	console.log(
		'[MAIN] Preload file exists:',
		fs.existsSync(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY)
	);

	mainWindow = new BrowserWindow({
		height: 800,
		width: 1200,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			nodeIntegration: false,
			contextIsolation: true,
			webSecurity: true,
		},
		transparent: true,
		frame: false,
		titleBarStyle: 'hidden',
		// Enable file drag and drop
		acceptFirstMouse: true,
	});

	// Listen for console messages from the renderer process
	mainWindow.webContents.on(
		'console-message',
		(event, level, message, line, sourceId) => {
			const levelMap: Record<number, string> = {
				0: 'INFO',
				1: 'WARN',
				2: 'ERROR',
				3: 'DEBUG',
			};
			const logLevel = levelMap[level] || 'LOG';
			console.log(`[RENDERER-${logLevel}] ${message}`);
		}
	);

	// Listen for when the renderer is ready
	mainWindow.webContents.once('did-finish-load', () => {
		console.log('[MAIN] Renderer finished loading');
	});

	// Listen for preload script errors
	mainWindow.webContents.on('preload-error', (event, preloadPath, error) => {
		console.error('[MAIN] Preload script error:', preloadPath, error);
	});

	// Listen for when DOM is ready
	mainWindow.webContents.once('dom-ready', () => {
		console.log('[MAIN] DOM ready');
	});

	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

	mainWindow.webContents.openDevTools();
};

app.on('ready', () => {
	createWindow();
});

app.on('window-all-closed', () => {
	if (process.platform !== 'darwin') {
		app.quit();
	}
});

app.on('activate', () => {
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow();
	}
});

ipcMain.handle(CHANNELS.readMetadata, async (event, filePath: string) => {
	console.log('[MAIN] readMetadata called for:', filePath);
	try {
		const result = await metadataService.readMetadata(filePath);
		console.log('[MAIN] readMetadata successful for:', filePath);
		console.log('[MAIN] metadata result:', result);
		return result;
	} catch (error) {
		console.error('[MAIN] readMetadata failed for:', filePath, error);
		throw error;
	}
});

ipcMain.handle(
	CHANNELS.writeMetadata,
	async (event, filePath: string, metadata: Wavedata) => {
		return metadataService.writeMetadata(filePath, metadata);
	}
);

ipcMain.handle(CHANNELS.openFile, async () => {
	const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
		properties: ['openFile'],
		filters: [{ name: 'WAV Files', extensions: ['wav'] }],
	});
	if (canceled || filePaths.length === 0) {
		return null;
	}
	return filePaths[0];
});

ipcMain.handle(CHANNELS.openDirectory, async () => {
	const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
		properties: ['openDirectory'],
	});
	if (canceled) {
		return { canceled: true, filePaths: [] };
	}
	return { canceled: false, filePaths };
});

ipcMain.handle(CHANNELS.scanDirectory, async (event, dirPath: string) => {
	try {
		const files = await fs.promises.readdir(dirPath);
		const wavFiles = files
			.filter((file) => path.extname(file).toLowerCase() === '.wav')
			.map((file) => path.join(dirPath, file));

		// Use the metadataService to read the metadata for each file
		const wavedataPromises = wavFiles.map((filePath) =>
			metadataService.readMetadata(filePath)
		);

		// Wait for all metadata to be read
		const wavedata = await Promise.all(wavedataPromises);
		return wavedata;
	} catch (error) {
		console.error(`Failed to scan directory ${dirPath}:`, error);
		return []; // Return empty array on error
	}
});

ipcMain.handle(CHANNELS.loadAudioFile, async (event, filePath: string) => {
	try {
		console.log('[MAIN] Loading audio file:', filePath);
		const buffer = await fs.promises.readFile(filePath);
		console.log('[MAIN] Audio file loaded successfully, size:', buffer.length);
		return buffer.buffer;
	} catch (error) {
		console.error(`Failed to load audio file ${filePath}:`, error);
		throw error;
	}
});

ipcMain.handle('start-file-watching', async (event, filePath: string) => {
	if (fileWatcher) {
		fileWatcher.close();
	}

	if (!filePath) return;

	fileWatcher = chokidar.watch(filePath, {
		persistent: true,
		ignoreInitial: true,
	});

	fileWatcher.on('change', () => {
		if (mainWindow && !mainWindow.isDestroyed()) {
			mainWindow.webContents.send('file-changed', filePath);
		}
	});

	fileWatcher.on('error', (error) => {
		console.error(`File watcher error: ${error}`);
	});
});

ipcMain.on('stop-file-watching', () => {
	if (fileWatcher) {
		fileWatcher.close();
		fileWatcher = null;
	}
});

app.on('before-quit', () => {
	if (fileWatcher) {
		fileWatcher.close();
	}
});

// Global error handlers
process.on('uncaughtException', (error) => {
	console.error('Uncaught Exception:', error);
	// Don't exit for destroyed object errors during shutdown
	if (error.message && error.message.includes('Object has been destroyed')) {
		console.log('Ignoring "Object has been destroyed" error during shutdown');
		return;
	}
	// For other critical errors, exit gracefully
	process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
	console.error('Unhandled Rejection at:', promise, 'reason:', reason);
	// Don't crash for destroyed object errors
	if (
		reason &&
		typeof reason === 'object' &&
		'message' in reason &&
		typeof (reason as any).message === 'string' &&
		(reason as any).message.includes('Object has been destroyed')
	) {
		console.log(
			'Ignoring "Object has been destroyed" rejection during shutdown'
		);
		return;
	}
});

ipcMain.handle(CHANNELS.checkIsDirectory, async (event, filePath: string) => {
	try {
		const stats = await fs.promises.stat(filePath);
		return stats.isDirectory();
	} catch (error) {
		return false;
	}
});

ipcMain.handle(CHANNELS.createTestFiles, async () => {
	// Dummy implementation
	return { success: true, directory: '/tmp/test-files' };
});

ipcMain.handle(CHANNELS.batchUpdateMetadata, async (event, updates) => {
	console.log('DUMMY: Batch update called with:', updates);
	return;
});

ipcMain.handle(
	CHANNELS.batchExtractMetadata,
	async (event, filePaths: string[]) => {
		console.log('[IPC] Received batchExtractMetadata request for:', filePaths);
		const results = filePaths.map((filePath) => {
			const filename = path.basename(filePath);
			const parsedData = filenameParser.parse(filename);
			if (parsedData) {
				return {
					...parsedData,
					filePath,
				};
			}
			return null;
		});
		const finalResults = results.filter((r) => r !== null);
		console.log('[IPC] Sending back extracted data:', finalResults);
		return finalResults;
	}
);

ipcMain.handle(CHANNELS.getAgentStatuses, async () => {
	console.log('DUMMY: Get agent statuses called');
	return [];
});

ipcMain.handle(CHANNELS.toggleAgent, async (event, name, active) => {
	console.log(`DUMMY: Toggle agent ${name} to ${active}`);
	return;
});

ipcMain.handle(CHANNELS.triggerAgent, async (event, name) => {
	console.log(`DUMMY: Trigger agent ${name}`);
	return;
});

// Mirror Feature IPC Handlers
ipcMain.handle(CHANNELS.selectMirrorDestination, async () => {
	const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
		properties: ['openDirectory', 'createDirectory'],
		title: 'Select Mirror Destination Directory',
	});
	if (canceled || filePaths.length === 0) {
		return null;
	}
	return filePaths[0];
});

// We need a way to pass the current files list to the mirror service
// Since we don't have global state in the main process, we'll need to pass it from renderer
let currentFiles: Wavedata[] = [];

ipcMain.handle(CHANNELS.setCurrentFiles, async (event, files: Wavedata[]) => {
	currentFiles = files;
	console.log('[MAIN] Current files updated, count:', files.length);
});

ipcMain.handle(
	CHANNELS.mirrorFiles,
	async (event, config: MirrorConfiguration) => {
		console.log('[MAIN] Mirror files requested with config:', config);
		try {
			const result = await mirrorService.mirrorFiles(config, currentFiles);
			console.log('[MAIN] Mirror operation completed:', result);
			return result;
		} catch (error) {
			console.error('[MAIN] Mirror operation failed:', error);
			throw error;
		}
	}
);

ipcMain.handle(
	CHANNELS.checkFileConflicts,
	async (event, config: MirrorConfiguration) => {
		console.log('[MAIN] Check file conflicts requested');
		try {
			const conflicts = await mirrorService.checkFileConflicts(
				config,
				currentFiles
			);
			console.log(
				'[MAIN] File conflicts check completed:',
				conflicts.length,
				'conflicts found'
			);
			return conflicts;
		} catch (error) {
			console.error('[MAIN] File conflicts check failed:', error);
			throw error;
		}
	}
);

// Debug helper to forward renderer logs to main console
ipcMain.handle(
	CHANNELS.debugLog,
	async (event, message: string, data?: any) => {
		console.log(
			`[RENDERER-DEBUG] ${message}`,
			data ? JSON.stringify(data, null, 2) : ''
		);
	}
);

// Progress and agent status will be updated when real operations occur
// No dummy periodic updates needed

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
